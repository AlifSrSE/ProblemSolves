# ğŸ PYTHON COMPETITIVE PROGRAMMING CHEATSHEET
# ğŸ”¥ v3.0 - TLE & MLE Optimization Master Guide

=== I/O OPTIMIZATIONS (TLE) ===
ğŸ“Œ [1] Ultra-fast input:
import sys
input = sys.stdin.read  # Reads ALL input
data = input().split()  # Process as list

ğŸ“Œ [2] Fast output:
sys.stdout.write(" ".join(map(str, arr)))  # 2x faster than print()

=== MEMORY OPTIMIZATIONS (MLE) ===
ğŸ“Œ [3] __slots__ for classes (40% less memory):
class Node:
    __slots__ = ['val', 'next']
    def __init__(self, val):
        self.val = val

ğŸ“Œ [4] Generators for large data:
def read_large_file():
    with open('big.txt') as f:
        yield from f  # No full storage

ğŸ“Œ [5] array.array for homogeneous data:
import array
arr = array.array('i', [1,2,3])  # 50% less RAM than list

=== DATA STRUCTURES ===
ğŸ“Œ [6] Deque (O(1) ops):
from collections import deque
q = deque([1,2,3])
q.appendleft(0)  # Fast left insert

ğŸ“Œ [7] Priority Queue:
import heapq
heapq.heappush(heap, (priority, item))

ğŸ“Œ [8] Memory-efficient dicts:
d = {}.fromkeys(keys, 0)  # Pre-allocated

=== ALGORITHM OPTIMIZATIONS ===
ğŸ“Œ [9] Sliding window template:
left = 0
for right in range(n):
    while invalid(window):
        left += 1
    update_answer()

ğŸ“Œ [10] DP space optimization:
dp_prev, dp_curr = [0]*n, [0]*n  # Only store last 2 states

=== BIT & MATH TRICKS ===
ğŸ“Œ [11] Bitmask compression:
mask = 0
mask |= (1 << 3)  # Set bit 3
if mask & (1 << 3):  # Check bit

ğŸ“Œ [12] Fast modular exponentiation:
pow(a, b, mod)  # (a^b)%mod

=== RECURSION CONTROL ===
ğŸ“Œ [13] Recursionâ†’Iteration:
stack = [(root, False)]
while stack:
    node, visited = stack.pop()
    if visited:
        process(node)
    else:
        stack.append((node, True))
        stack.extend((child, False) for child in children)

=== NUMPY (When Allowed) ===
ğŸ“Œ [14] Memory-efficient arrays:
import numpy as np
arr = np.zeros(10**6, dtype=np.int32)  # 4MB vs 8MB list

=== DEBUGGING ===
ğŸ“Œ [15] Memory measurement:
import sys
x = [0]*10**6
print(sys.getsizeof(x)//1024, "KB")

ğŸ“Œ [16] Time measurement:
from time import perf_counter
start = perf_counter()
# Code
print(f"{perf_counter()-start:.5f}s")

=== CONTEST STRATEGIES ===
ğŸ“Œ [17] MLE Prevention:
1. Use generators/yield
2. Delete temp vars (del x)
3. Avoid globals â†’ use locals
4. Test with max input size

ğŸ“Œ [18] TLE Prevention:
1. Replace nested loops
2. Use set/dict for O(1) lookups
3. Precompute values
4. Use PyPy for recursion

# ğŸš€ Last-Minute Checklist
âœ… TLE:
  - Replaced input() with sys.stdin?
  - Avoided O(nÂ²) algorithms?
  - Used set/dict for lookups?

âœ… MLE:
  - Used __slots__ in classes?
  - Deleted large temp vars?
  - Converted recursionâ†’iteration?

# ğŸ¯ PRO TIPS
â€¢ PyPy uses less memory for some cases
â€¢ For O(nÂ²)â†’O(n), try two pointers
â€¢ Bitmasking saves memory for flags
â€¢ 1e6 ints = ~8MB (list) vs ~4MB (array.array)